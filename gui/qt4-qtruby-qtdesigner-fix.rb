# Author: Cosmin Pitu <pitu.cosmin@gmail.com>, http://bit.ly/dr1ku
#         ("Use at your own risk. Please do not use it for evil. Feedback is welcome. Thank you.")
#         [http://www.json.org/java/]
#				
# License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
#          (http://creativecommons.org/licenses/by-nc-sa/3.0/)
#				 
# Usage: Develop your Qt UI using Qt Designer (tested under Qt 4.3.4 Open-Source Edition), leaving
#        all slots empty (labeled as "<slot>" within Qt Designer) and assigning the signals to the
#        MainWidget for instance. Then edit the qt4-qtruby-qtdesigner-fix.cfg (or another custom
#        configuration file with the same format) and add a Header and Header Items (see method
#        ConfigurationFile::create_default for more info). Lastly, run this program with the name
#        of the .ui.rb file (generated by rbuic4) which is to be fixed. Check out output and see
# 			 if all went well. You can run the fixed .ui.rb file afterwards. You can also look within 
#        the source (this .rb file) for more advanced tweaking, if need arises. 
#
# Conventions: If the Header name contains 'central' / 'Central' then it will be considered to be 
#							 the central Widget of a MainWindow. Otherwise the dialog will be considered a normal 
#              Dialog / Widget. If the dialog is *not* part of a MainWindow, then all the slot 
#              receivers will be rerouted to the handler for that given block automatically. 
#              Just be sure to write *all* required elements for signal/slot pairing.

			##########################################
			# TODO: Class-ify, OO-ize.
      # TODO: Use heredocs
			##########################################


#
# Tip: Best paired with http://github.com/wfslogx-win32-file-monitor for automated GUI compilation
#      upon file change.

#
# Note: Main entry point at the bottom of this file
#

# Print it pretty
require "pp"

# String extensions
class String

	# Source: http://apidock.com/rails/Inflector/camelize
	# File activesupport/lib/active_support/inflector.rb, line 160
  def camelize
		self.gsub(/\/(.?)/) { "::#{$1.upcase}" }.gsub(/(?:^|_)(.)/) { $1.upcase }
  end
	
	# Converts a "SomeRandomWidgetName" to "@someRandomWidgetName"
	def instance_variableize(p_already_had_at_symbol = false)
	
		# Default settings, @Uppercase letters within the string
		reg_exp_base = (p_already_had_at_symbol ? "@[A-Z]" : "^[A-Z]{1}")
		idx = (p_already_had_at_symbol ? 1 : 0)
		
		# Create RegExp
		reg_exp = Regexp.new(reg_exp_base)
		
		# Sanitizes input, copies to a temporary variable
		result = self.strip
		
		# Camelize in preperation for the substitution
		result = result.camelize unless p_already_had_at_symbol
					
		# Perform global substitution, lowercase at specified index and return
		result.gsub!(reg_exp) { |found_str| 
			found_str[idx] += 32
			found_str.insert(0, "@") unless p_already_had_at_symbol
			found_str			
		}
		
		# Return copy
		result
	end
	
end # class String

# Models a configuration file (.ini -like)
class ConfigurationFile

	# Default constructor, initializes fields
	def initialize
	
		# Store sanitized input file name
		@input_file = sanitize_input_file	
	
		# Determine final configuration file to be used
		check_config_file
			
		# Initialize Configuration File specific keywords and delimiters
		initialize_control_chars
		initialize_keywords
		initialize_internal
		
		# Initialize Blocks (fully read blocks), last header
		@blocks = []
		@last_header = nil
		
		# Initialize current block as not yet found
		initialize_current_block
				
	end # initialize
	
	# Verifies provided config file
	def check_config_file
	
		# Get second argument (custom Configuration File)
		@@config_file = ARGV[1]
		
		# Construct fallback filename
		fallback_filename = @input_file.sub(".rb", "") + ".cfg"
		
		# Check if external configuration file provided
		unless File.exists?(@@config_file)
			puts "WARNING: No configuration file specified as second arg, writing empty config to '#{fallback_filename}'\n\n"
		end		
		
		# Use first argument (input file) + .cfg
		@@config_file = fallback_filename
		
	end # check_config_file
	
	# Initializes control characters used in configuration files
	def initialize_control_chars
		# Line comment char (Ruby-style by default)
		@@comment_char = '#'
		
		# Header separators
		@@block_header_separator_begin = '['
		@@block_header_separator_end   = ']'
	end
	
	# Initializes the keywords used throughout the Configuration File
	def initialize_keywords
		# Define keywords, :repeat means that the keyword should be searched
		# more than once per block, :override redefines the way a result is
		# parsed (:inner) and the way it is stored (:outer). You can also add
		# a :optional key to mark the keyword as being optional. All keywords 
		# are marked as required by default (e.g. no :optional key is present)
		@@keywords = [
			{ :name => "Handler" },
		  { :name => "ClassName" },
									 
			{ 
				:name => "SigSlot", 
				:repeat => true, :optional => true,
				:override =>
				{ 
					:inner => lambda { |result| process_signal(result.split(",")) },
					
					:outer => lambda { |result| 
						block = @current_block["SigSlot"]
						block[:value] ||= []
						block[:value] << result unless result.nil? 
					}
				}
			}
		]

		# Internal conventions used to differentiate between the various
		# types of construct one can devise in Qt (a MainWindow, a Dialog,
		# or a Widget). Be sure to include the proper construct within your
		# headers (part of a Configuration File), since the code fixes 
		# included differ from case to case. Check out console output for
		# (hopefully helpful) clues as to what went wrong while fixing.
		@@conventions = {
			:main_window => "central",   # Use CentralWidget, CentralWindowWidget, centralWidget, centralw and so on to mark a MainWindow
			:dialog => "form",           # Use MyForm, xform and so on to mark a Dialog
			:widget => "widget",         # Use MyWidget, xWidget and so on to mark a Widget
			
			:qt_designer_default_slot => "close()", # ############ TODO: DOCUMENT
		}
	end
	
	# Initializes internal settings
	def initialize_internal
	
		# Internal constants
		@@consts = {
			:dialog_instance_var => "@extension"
		}
	end
	
	# Clears out the current block
	def initialize_current_block
		@current_block = {}

		@@keywords.each do |keyword|
			@current_block[keyword[:name]] = { :found => false, :value => nil }
			@current_block[keyword[:name]][:repeat]   = true if keyword.has_key?(:repeat)
			@current_block[keyword[:name]][:optional] = true if keyword.has_key?(:optional)
		end	
	end
	
	# Adds a fully read block to the collection
	def cache_read_block
		@blocks << @current_block
		initialize_current_block
	end		
	
	# Helper Method, reads the configuration file
	def read
	
		# Check if configuration file exists
		return unless config_exists
		
		# Read through every line of the configuration file
		IO.readlines(@@config_file).each do |line|
		
			# Store current line
			@current_line = line
		
			# Get first char of line, skip if is commented out
			first_char = @current_line[0].chr
			next if first_char.eql?(@@comment_char)
					
			# Try to get header from current line
			next if found_header(first_char)
					
			# Try to get keyword from current line
			next if keyword_present
					
		end # readlines
		
		# Cache the last read block 
		cache_read_block
	end
		
	# Determines if the current line stands for a block header
	def found_header(p_first_char)
	
		# Initialize result
		result = false
	
		# If a block header begin separator found (usually '[')
		if p_first_char.eql?(@@block_header_separator_begin)
		
			# Mark that block header was found
			result = true
		
			# Check if a new header was found, cache last read block 
			cache_read_block unless @last_header.nil?
			
			# Get header end separator (usually ']'), warn and skip if not present
			idx = @current_line.index(@@block_header_separator_end)
			if idx.nil?
				puts "WARNING: Header '#{@current_line.strip}' not proper! \n" +
						 "         Should be #{@@block_header_separator_begin}myMainWindow#{@@block_header_separator_end}. Skipping!\n"
			else
				# Set header name for current block, store last found header, move on to next line
				@current_block[:header] = @current_line[1..idx - 1]
				@last_header = @current_block[:header]	
			end
			
		end	# if first_char
		
		# Return result
		result
	end 
	
	# Determines if the current line represents a keyword/value pair
	def keyword_present

		# Prepare result
		block_parse_result = false
	
		# Iterate through all keywords
		@@keywords.each do |keyword|
		
			# Initialize overrides, none by default
			keyword_override = nil
		
			# Store keyword name, current status
			keyword_name = keyword[:name]
			keyword_data = @current_block[keyword_name]
			
			# Determine if keyword has already been found, get eventual overrides
			keyword_found = keyword_data[:found]
			keyword_override = keyword[:override] if keyword.has_key?(:override)
		
			# Parse keyword if not already found
			unless keyword_found

				# Get block item
				block_parse_result = get_block_item(keyword_name, keyword_override)

				# Eventually mark as found
				keyword_repeatable = keyword_data.has_key?(:repeat)
				keyword_data[:found] = !keyword_repeatable
								
				# Store and exit iteration
				keyword_data[:value] = block_parse_result
				break
			end
			
		end # each	
		
		# Return result
		block_parse_result
	end	
	
	# Wraps default keyword processing and eventual extensions
	def get_block_item(p_keyword, p_override = nil)	
		
		# Parse optional arguments
		override_inner = override_outer = nil
		unless p_override.nil?
			override_inner = p_override[:inner]
			override_outer = p_override[:outer]
		end
	
		# Get keyword value with default processing and eventual extensions
		result = get_keyword_value(p_keyword, override_inner) 
			
		# Process result with eventual extensions
		result = override_outer.call(result) unless override_outer.nil?
		
		# Return result
		result
	end
	
	# Utility method, sanitizes the given value for a eventually found keyword
	def get_keyword_value(p_keyword, p_override_inner = nil)
		# Initialize result
		result = nil
		
		# Get possible idx
		idx = @current_line.index(p_keyword)
	
		# If found, store sanitized handler value
		unless idx.nil?
			result = sanitize_key_value_string(@current_line[idx + p_keyword.length..@current_line.length])
			result = p_override_inner.call(result) unless p_override_inner.nil?
		end				
					
		# Return result
		result
	end	
	
	# Utility method, sanitizes a given 'Key=Value' string
	def sanitize_key_value_string(p_str)
		p_str.sub("=", "").strip
	end
	
	# Processes a comma-split list of signal-related strings,
	# looks to merge runaway arguments from one string to the
	# other (e.g. *comma-separated* arguments of a signal or slot)
	def process_signal(p_array)
	
		# Prepare intermediate result
		intermediate_result = []
		
		# Iterate through the parsed strings, add to intermediate result 
		# if a runaway argument (last character is a closed paranthesis)
		p_array.each_with_index do |item, i|			
			intermediate_result << i if item.sub("'", "").reverse[0].chr == ")"
		end
		
		# Prepare deleted count, use to sanitize indexes
		delete_count = 0
		
		# Iterate through the intermediate results
		intermediate_result.each do |index|
		
			# Recompute index based on previously deleted items
			actual_index = index - delete_count
				
			# Delete and store runaway argument
			argument = p_array.delete_at(actual_index)
			delete_count += 1
						
			# Checking just in case
			unless argument.nil?
				
				# Compute previous index
				previous = actual_index - 1
				
				# Ignore just in case, if out of bounds (unlikely)
				next if previous < 0
				
				# Reunite runaway argument with others
				p_array[previous] = "#{p_array[previous]},#{argument}"
				
			end
		end # each
			
		# Return result
		p_array
  end

  # Utility method, injects a class method which
  # retrieves all children widgets for the current
  # widget.
  #
  # Adapted from :
  #   http://stackoverflow.com/questions/2487333/fastest-one-liner-way-to-list-attr-accessors-in-ruby
  #
  def attr_reader_filter(p_extension_sym)
    <<-CHILDREN_ACCESSOR
    def self.attr_reader(*p_args)
      @children_widgets ||= []
      @children_widgets.concat(p_args)
      super
    end
    def self.children_widgets; @children_widgets - [:#{p_extension_sym}] end
    def children_widgets; self.class.children_widgets end
    CHILDREN_ACCESSOR
  end
	
	# Utility method, processes collected blocks
	def process
		
		# Prepare result
		result = []
			
		# Iterate through all read blocks
		@blocks.each do |block|
				
			# Check for invalid block items (a required, yet empty block item)
			invalid_block = false
			invalid_block_items = []
			
			block.each do |key, value_hash|
				if value_hash.is_a?(Hash) && !value_hash.has_key?(:optional) && value_hash[:value].nil?
					invalid_block = true
					invalid_block_items << key
				end
			end
							
			# Notify invalid block
			if invalid_block
			
				# Only notify when there is a header to mention
				unless block[:header].nil?
				
					# Error output
					STDERR.puts "ERROR: Block labeled #{@@block_header_separator_begin}#{block[:header]}#{@@block_header_separator_end} " +
											"       does not contain the following required block items :\n\n"			
				
					# Iterate through invalid block items
					invalid_block_items.each do |invalid_block_item|
						puts "\t'#{invalid_block_item}'"
					end
					
					# Leave a tip
					STDERR.puts "\n     Mark as optional if required. Please recheck the input file, block discarded.\n\n"
				end

				# Proceed to next block
				next								
			end
								
			# Shorthand block header, use lowercase header name to identify Qt construct type
			header = block[:header]
			header_lower = header.downcase
			
			# Shorthand block items
			handler = block["Handler"][:value]
			ui_extension_class_name = block["ClassName"][:value]
			sig_slots = block["SigSlot"][:value]			
		
			# Convert 'main_window.ui.rb' to CamelCase, e.g. MainWindow, generate hash for class declaration
      ui_class_target = header_lower.include?(@@conventions[:main_window]) ? File.basename(@input_file) : header

			ui_class_name_camel = ui_class_target.camelize.sub(".ui", "").sub(".rb", "")
			class_declaration = "class Ui_#{ui_class_name_camel}"

      # Modify and inject
      dialog_instance_var_sym = @@consts[:dialog_instance_var].sub("@", "")
      class_declaration_inject =
        "#{class_declaration} < Qt::Widget"+
        "\n\n#{attr_reader_filter(dialog_instance_var_sym)}"+
				"\n\t\tattr_reader :#{dialog_instance_var_sym}"

			class_declaration_replace = { :from => class_declaration, :to => class_declaration_inject }
			result << class_declaration_replace
			
			# Prepare Class Extension (e.g. MainWindowExt)
			require_ui_extension = "require \"\#{File.dirname(__FILE__)}/#{handler}\";"
			
      ############# TODO : Code injections as HERE docs   ###################
			############# TODO : CAMEL CLASS STUFF BLA REFACTOR ###################
			
			# Handle CentralWidget, part of a QMainWindow
			if header_lower.include?(@@conventions[:main_window])
						
				# Convert CamelCase class name to first letter lowercase camel, e.g. mainWindow, generate half of hash for header
				ui_class_name_camel[0] += 32
				
				############# TODO : FIRST LETTER LOWERCASE STUFF REFACTOR TO STRING EXTENSIONS ###################
				
				header[0] += 32
				hash = { :from => "@#{header} = Qt::Widget.new(#{ui_class_name_camel})" } 
							
				# Convert first letter lowercase camel back to CamelCase, e.g. MainWindow, generate extension class name
				ui_class_name_camel[0] -= 32
				ui_extension_class_name ||= "#{ui_class_name_camel}Ext"

				# Convert CamelCase to first letter lowercase camel, e.g. mainWindow, generate extension class instantiation
				ui_class_name_camel[0] += 32
				instantiation = "@#{header} = #{ui_extension_class_name}.new(self, #{ui_class_name_camel})"
				
				# Generate other half of hash for header, add to result
				hash[:to] = require_ui_extension + instantiation

        # Return header to lowercase
				header[0] -= 32
							
				result << hash
      else

				# Handle QDialog / QWidget
				if header_lower.include?(@@conventions[:dialog]) ^ header_lower.include?(@@conventions[:widget])
				
					# Convert CamelCase class name to first letter lowercase camel, e.g. mainWindow
					ui_class_name_camel[0] += 32
					
					# Inject a method to retrieve all other children widgets,
          # Class Extension require and instantiation
					require_and_instantiation =
            "\n\t\t#{require_ui_extension}"+
            "\n\t\t#{@@consts[:dialog_instance_var]} = #{ui_extension_class_name}.new(self, #{ui_class_name_camel})\n"

					# String to find the "setupUi" method by (method generated via rbuic4)
					setup_ui_def = "def setupUi(#{ui_class_name_camel})"
					
					# Convert first letter lowercase camel back to CamelCase, e.g. MainWindow
					ui_class_name_camel[0] -= 32

					result << { :from => setup_ui_def, :to => setup_ui_def + require_and_instantiation }
				end
			end
			
			# Skip if no signal/slot pairs were found
			next if sig_slots.nil?
								
			# Generate signal/slots replacements, notify if something goes amiss
			begin
				sig_slots.each do |sig_slot|

					receiver_old = receiver_new = "@#{sig_slot[2]}"
					sender_old = sender_new = "@#{sig_slot[0]}"
					
					# If it's a self-reference (e.g. the actual form), remove instance var prefix
					if receiver_old == sender_old
						sender_old.sub!("@", "")
						sender_new = sender_old
					end
					
					########################## TODO: Specify as block-level attr ########################
									
					if header_lower.include?(@@conventions[:dialog])
						receiver_old.sub!("@", "")
						receiver_new = @@consts[:dialog_instance_var]
					end		
														
					replace_hash = { 
						:from => "Qt::Object.connect(#{sender_old}, SIGNAL(#{sig_slot[1]}), #{receiver_old}, SLOT('#{@@conventions[:qt_designer_default_slot]}'))",
						:to   => "Qt::Object.connect(#{sender_new}, SIGNAL(#{sig_slot[1]}), #{receiver_new}, SLOT(#{sig_slot[3]}))" 
					}

					result << replace_hash
				end
			rescue Exception => e
				pp e.message
				STDERR.puts "ERROR: Signal/Slot pairing misfired, don't forget to list all required elements !\n"
				STDERR.puts "       (e.g. myEmitter,'mySignal()',myReceiver,'my_slot()')"
			end
			
		end # each
		
		# Return result
		result
	end	
	
	# Determines if a given configuration file exists
	def config_exists
		result = File.exists?(@@config_file)
	
		if !result
			puts "ERROR: Configuration File ('#{@@config_file}') not found, recreating default template!\n"
			puts "       Don't forget to add proper items to this file ! Exiting.\n"
			generate_default
			exit(-2)
		end		
		
		# Return result
		result
	end
	
	# Generates the default configuration file header
	def generate_default
		# Create new default config file
		cfg = File.new(@@config_file, "w")
		
		# Write default, explanatory lines
		cfg.puts "# Qt4RubyQtDesignerFixer Default Configuration File Header" 
		cfg.puts "# ----------------------------------------------------------------------------"
		cfg.puts "#"
		cfg.puts "# Usage: Declare a QWidget/QMainWindow"
		cfg.puts "#        within square brackets, such"
		cfg.puts "#        as [myMainWindow], where the"
		cfg.puts "#        name corresponds *exactly* to"
		cfg.puts "#        the given Qt .ui File -- if"
		cfg.puts "#        it's a QWidget, then the objectName"
		cfg.puts "#        ; if it's a QMainWindow, then the"
		cfg.puts "#        objectName of the window's mainWidget."
		cfg.puts "#"
		cfg.puts "# Handler: After the declaration (square"
		cfg.puts "#          brackets) part, use the following"
		cfg.puts "#          syntax to describe a UI Handler :"
		cfg.puts "#          Handler = my_main_window_ext.rb."
		cfg.puts "#"
		cfg.puts "#          A Handler extends the MainWidget"
		cfg.puts "#          of a given QMainWindow or a given"
		cfg.puts "#          QWidget and contains all of the"
		cfg.puts "#          children of the QMainWindow/QWidget."
		cfg.puts "#"
		cfg.puts "#          Thus, within the Handler Ruby File,"
		cfg.puts "#          one declares the class (CamelCase),"
		cfg.puts "#          e.g. class MyWainWindowExt. This class"
		cfg.puts "#          *must* subclass Qt::Widget, so that"
		cfg.puts "#          mixins such as 'signals' and 'slots'"
		cfg.puts "#          are made available."
		cfg.puts "#"
		cfg.puts "# Class Name: After the declaration (square"
		cfg.puts "#             brackets) part, use the following"
		cfg.puts "#             syntax to describe the name of the Class"
		cfg.puts "#             contained within the Handler Ruby Source:"
		cfg.puts "#             ClassName = MyMainWindowExt. This"
		cfg.puts "#             parameter is optional."
		cfg.puts "#"
		cfg.puts "# Signals and Slots: Within the same square brackets"
		cfg.puts "#                    block, one declares a signal-slot"
		cfg.puts "#                    combo in the following manner :"
		cfg.puts "#                    SigSlot =  browseButton,'clicked()',mainWidget,'foo(int)'"
		cfg.puts "#                    You can add as many of these SigSlot"
		cfg.puts "#                    as you wish for signal/slot pairs ." 
		cfg.puts "#"
		cfg.puts "#                    Above, the signal 'clicked' emitted"
		cfg.puts "#                    by the component 'browseButton' is"
		cfg.puts "#                    sent to the 'foo(int)' slot within"
		cfg.puts "#                    the 'mainWidget' Component (in this case"
		cfg.puts "#                    this represents the Main Widget of the"
		cfg.puts "#                    QMainWindow. The handler foo(int) must"
		cfg.puts "#                    be declared within a Handler class."
		cfg.puts "#"
		cfg.puts "#                    The Handler should contain a constructor"
		cfg.puts "#                    with (QWidget, QMainWindow) arguments."
		cfg.puts "#"
		cfg.puts "# Note: Naming conventions from rbuic4 are"
		cfg.puts "#       lowerCamelCase, so even if the Main Widget"
		cfg.puts "#       is named SOMETHINGNice, it will evaluate"
		cfg.puts "#       to sOMETHINGNice, MainWidget = mainWidget"
		cfg.puts "#       and so on. Worst case scenario: trial and error."
		cfg.puts "#       The lowerCamelCase applies to all components"
		cfg.puts "#       (e.g. all objectNames) !"
		cfg.puts "#"
		cfg.puts "# Trubleshooting: Refer to the console's output. See sample below."
		cfg.puts "#"
		cfg.puts "#"
		cfg.puts "# Sample configuration file:"
		cfg.puts "#"
		cfg.puts "# [myMainWidget]"
		cfg.puts "# Handler = main_window_ext.ui.rb"
    cfg.puts "# SigSlot = myButton,'clicked()',mainWidget,'something(int)'"
		cfg.puts "# ClassName = MainWindowWidgetExtension"
		cfg.puts "#"
		cfg.puts "# Sample Usage: 'ruby qt4-qtruby-fix main_window.ui' will"
		cfg.puts "#                 * Compile main_window.ui via rbuic4"
		cfg.puts "#                 * Fix KDE references within main_window.ui.rb (if any)"
		cfg.puts "#                 * Make Ui_MainWindow subclass Qt::Widget"
		cfg.puts "#                 * require 'main_window_ext.ui.rb'"
		cfg.puts "#               	* instantiate @myMainWidget not as Qt::Widget.new(mainWindow), but"
		cfg.puts "#                   as MainWindowWidgetExtension.new(self, mainWindow) "
		cfg.puts "#                 * connect @myButton's clicked() signal to @mainWidget's"
		cfg.puts "#                   something(int) slot."
		cfg.puts "#"
		cfg.puts "# You may insert Handlers, Signals and Slots below." 
		cfg.puts "# ----------------------------------------------------------------------------"
		
		# Close default config file
		cfg.close
	end
end

# Main Functionality, fixes a .ui.rb File generated by rbuic4
class Qt4RubyQtDesignerFixer

	# Default constructor, initializes fields
	def initialize(p_extra_replaceables = nil)
	
		# Initialize actionable lines (removable, replaceable, reprocessable)
		initialize_actionables
		
		# Initialize input filename
		@input_file = sanitize_input_file
		
		# Backup default replaceables
		@@original_replaceables = @@replaceables.dup
		
		# Eventually add extra replaceables
		unless p_extra_replaceables.nil? && p_extra_replaceables.is_a?(Hash)
			@@replaceables += p_extra_replaceables
		end
	
		# Prepare output file
		@out_file = File.new(@input_file + ".new", "w")
	end
	
	# Initializes actionable lines (lines which can either be
	# removed, replace or reprocessed from a rbuic4-generated
	# .ui.rb File)
	def initialize_actionables
	
		# Lines (fragments thereof), which are to be removed
		@@removables = [
			"about = KDE::AboutData.new",
			"KDE::CmdLineArgs.init",
			"a.topWidget",
		]

		# Lines (fragments thereof), which are to be replaced
		@@replaceables = [
			{ :from => "require 'korundum4'", :to => "require 'qt4'" },
			{ :from => "a = KDE::Application.new", :to => "a = Qt::Application.new(ARGV)" }
		]	
		
		# Lines (fragments thereof), which are to be reprocessed
		# Declare process inline, only small fixes
		@@reprocessables = [

			# Problem with .raise() : calls are given to CamelCasedVariables, which are converted to @lowerCamelInstanceVars by rbuic4
			{ :keyword => ".raise()", :process => lambda { |raise_str| raise_str.instance_variableize } },
			
			# Problem with .setTabOrder() : calls are given @CamelCasedVariables by rbuic4, should be converted to @lowerCamelInstanceVars
			{ :keyword => "Qt::Widget.setTabOrder", :process => lambda { |tab_order_str| tab_order_str.instance_variableize(true) } }
		]
	end
	
	# Reads the input file (arg[0]), searching for lines of interest
	def scan_input_file
	
		begin

      # Cache constants
      #translate_call = @@consts[:qt_translate_call]

			# Line by line scanning
			IO.foreach(@input_file) do |line|

				# Flag, marks if a removable [Boolean true], 
				# replaceable [String, to replace string] or
				# regular [Fixnum, 0] line was found
				found = 0
				
				########################## TODO : REFACTOR BELOW #########################

				# If line is removable
				@@removables.each_with_index do |removable, i|
					if line.include?(removable)
						@@removables.delete_at(i)
						found = 1 
						break
					end
				end
					
				# If line is replaceable
				@@replaceables.each_with_index do |replaceable, i|
					if line.include?(replaceable[:from])
						@@replaceables.delete_at(i)
						found = replaceable[:to] 
						break
					end
				end
				
				# If line is reprocessable, modify (reprocess)
				@@reprocessables.each do |reprocessable|
					if line.include?(reprocessable[:keyword])
						found = reprocessable[:process].call(line) 
						break
					end
				end			
				
				# Add non-interesting lines to output file
				if found.is_a?(Fixnum) && found == 0
					@out_file << line
					next
        end

        # Fix Qt Rich-text strings
        #if line.include?(translate_call)
        #  puts line
        #end
									
				# Replace interesting lines before adding to output file
				if found.is_a?(String)
					@out_file << "\t\t#{found}\n"
					next
				end
				
			end	# IO.foreach
			
    rescue Exception => e
      				puts "Oops, exception: '#{e}'"
				puts e.backtrace.join("\n")
			#puts "File '#{@input_file}' not found, aborting !"
      #puts
			exit(-3)
		end
	end # scan_input_file
	
	# Replace input file with newly created output file
	def replace_old_file
    
		# Close output file
		@out_file.close

		# Delete old file, rename new file to take its place
		File.delete(@input_file)
		File.rename("#{@input_file}.new", "#{@input_file}")	
	end
	
	# Lists Removables and Replaceables for which no action was taken (e.g. they were not found)
	def list_mismatches
		
		# Output mismatched removables
		unless @@removables.empty?
			puts "INFO: The following strings were not found in '#{@input_file}'."
      puts "      Possible cause: rbuic4 functioned better ::\n\n"
			@@removables.each { |removable| puts "\t#{removable}" }
		end
		puts
		
		# Output mismatched replaceables. Hooray for Ruby -- Hash difference ftw.
		operand = (@@original_replaceables.length > @@replaceables.length ? @@replaceables : @@original_replaceables)
		diff = @@replaceables.send("-", operand)
		
		# Distinguish between failed signal/slot connect attempts and other replaceables
		non_signals = diff.reject { |replaceable| replaceable[:from].include?("Qt::Object.connect") }
		
		# Print unmatched non-default replaceables, which are not failed signal/slot connects
		unless non_signals.empty?
			puts "WARNING: The following strings were not found. \n" +
					 "         Possible cause: slightly incorrect Configuration File !\n\n"
			diff.each do |replaceable| 
				puts "   from: \n\t#{replaceable[:from]}\n   to: \n\t#{replaceable[:to]}\n--------\n"
			end
			puts		
		end
		
		# Print unmatched signal/slot connects
		unmatched_signals = diff - non_signals
		unless unmatched_signals.empty?
			puts "WARNING: The following signal/slot pairs were not found. \n" +
					 "         Please check the emittants, signals, receivers and slots :\n\n"
			unmatched_signals.each do |signal_string|
				signal_string = signal_string[:from]
				components = signal_string.sub("Qt::Object.connect(", "").sub(")", "").gsub(" ", "").split(",")
				puts "    Sender  : '#{components[0]}'"
				puts "    Signal  : '#{components[1]}'"
				puts "    Receiver: '#{components[2]}'"
				puts "    Slot    : '#{components[3]}'"
				puts "    ---------"
			end
			puts
		end
	end
	
	# Main entry point
	def start
		scan_input_file
		replace_old_file
	end	
	
end # class Qt4RubyQtDesignerFixer

# Utility method, creates a sanitized string from the input file name
def sanitize_input_file
	"#{File.dirname(__FILE__)}/#{ARGV[0].gsub("\\", "/")}"
end

# Main entry point of this program
def main

	# Declare constants
	@@default_cfg_file = "qt4-qtruby-qtdesigner-fix.cfg"

	# Print out info header
	puts "qt4-qtruby Fixer (http://github.com/Dr1Ku/qt4-qtruby-qtdesigner-integration)\n"
	puts "----------------------------------------------------------------------------\n\n"
	puts "Purpose: Fixes incomplete QtDesigner - qt4-qtruby integration"
	puts "         Visit GitHub for more information (link above)"
	puts "         Created by Dr1Ku (http://bit.ly/dr1ku)\n\n"
	puts "----------------------------------------------------------------------------\n"
		
	# Check first argument: a QtDesigner .ui File
	if ARGV[0].nil?
		puts "ERROR: No parameter specified!"
		puts "SAMPLE USAGE: rbuic4 -x my.ui > my.ui.rb;"
		puts "              rbrcc -name my > my.qrc.rb"
		puts "              ruby qt4-qtruby-qtdesigner-fix.rb my.ui.rb"
		exit(-1)
	end
	
	# Reset second argument if not present: a qt4ruby-qtdesigner-fix ConfigurationFile
	ARGV[1] = nil if ARGV[1].is_a?(String) && ARGV[1].empty?
	
	# Read and process configuration file
	cfg = ConfigurationFile.new
	cfg.read
	extra_replaceable = cfg.process
	
	# Start fixing
	fixer = Qt4RubyQtDesignerFixer.new(extra_replaceable)
	fixer.start
	fixer.list_mismatches

	# Notify program completed successfully
	puts "----------------------------------------------------------------------------\n"	
	puts "qt4-qtruby Fixer completed, enjoy.\n\n"
		
	# Everything went smooth
	exit(0)
end # main

# Call main method
main